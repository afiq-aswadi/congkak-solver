from collections.abc import Sequence
from enum import IntEnum

class StartMode(IntEnum):
    Sequential = 0
    SimultaneousIndependent = 1
    SimultaneousLeaderFollower = 2

class LeaderSelection(IntEnum):
    Random = 0
    AlwaysP0 = 1
    AlwaysP1 = 2

class SimultaneousPhase(IntEnum):
    AwaitingMoves = 0
    AwaitingFollower = 1
    ReadyToExecute = 2

class SimultaneousMoveState:
    phase: SimultaneousPhase
    p0_move: int | None
    p1_move: int | None
    leader: int | None

    @staticmethod
    def for_independent() -> SimultaneousMoveState: ...
    @staticmethod
    def for_leader_follower(leader: int) -> SimultaneousMoveState: ...
    def submit_move(self, player: int, pit: int) -> bool: ...
    def get_leader_move(self) -> int | None: ...
    def can_submit(self, player: int) -> bool: ...
    def reset(self) -> None: ...
    def __repr__(self) -> str: ...

class BoardState:
    pits: tuple[int, ...]
    current_player: int

    def __init__(self) -> None: ...
    @staticmethod
    def initial() -> BoardState: ...
    @staticmethod
    def from_pits(pits: Sequence[int], current_player: int) -> BoardState: ...
    def get_store(self, player: int) -> int: ...
    def get_pit(self, index: int) -> int: ...
    def player_pits(self, player: int) -> list[int]: ...
    @staticmethod
    def player_store_index(player: int) -> int: ...
    @staticmethod
    def player_pit_range(player: int) -> tuple[int, int]: ...
    def total_seeds(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...

class RuleConfig:
    start_mode: StartMode
    leader_selection: LeaderSelection
    capture_enabled: bool
    capture_requires_loop: bool
    forfeit_enabled: bool
    burnt_holes_enabled: bool

    def __init__(
        self,
        start_mode: StartMode = ...,
        leader_selection: LeaderSelection = ...,
        capture_enabled: bool = True,
        forfeit_enabled: bool = True,
        burnt_holes_enabled: bool = False,
        capture_requires_loop: bool = False,
    ) -> None: ...
    @staticmethod
    def default_rules() -> RuleConfig: ...
    def __repr__(self) -> str: ...

class MoveResult:
    state: BoardState
    extra_turn: bool
    captured: int

class SimultaneousMoveResult:
    state: BoardState
    p0_extra_turn: bool
    p1_extra_turn: bool
    p0_captured: int
    p1_captured: int

def apply_move(state: BoardState, pit: int, rules: RuleConfig) -> MoveResult: ...
def apply_simultaneous_moves(
    state: BoardState, p0_pit: int, p1_pit: int, rules: RuleConfig
) -> SimultaneousMoveResult: ...
def get_legal_moves(state: BoardState) -> list[int]: ...
def is_terminal(state: BoardState) -> bool: ...
def get_winner(state: BoardState) -> int: ...
def get_final_scores(state: BoardState) -> tuple[int, int]: ...
def random_playout(state: BoardState, rules: RuleConfig, seed: int) -> int: ...
def batch_random_playouts(
    state: BoardState, rules: RuleConfig, num_playouts: int, base_seed: int
) -> tuple[int, int, int]: ...
def perft(state: BoardState, rules: RuleConfig, depth: int) -> int: ...
