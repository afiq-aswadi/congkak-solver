from collections.abc import Sequence

class BoardState:
    pits: tuple[int, ...]
    current_player: int

    def __init__(self) -> None: ...
    @staticmethod
    def initial() -> BoardState: ...
    @staticmethod
    def from_pits(pits: Sequence[int], current_player: int) -> BoardState: ...
    def get_store(self, player: int) -> int: ...
    def get_pit(self, index: int) -> int: ...
    def player_pits(self, player: int) -> list[int]: ...
    @staticmethod
    def player_store_index(player: int) -> int: ...
    @staticmethod
    def player_pit_range(player: int) -> tuple[int, int]: ...
    def total_seeds(self) -> int: ...
    def __hash__(self) -> int: ...
    def __eq__(self, other: object) -> bool: ...
    def __repr__(self) -> str: ...

class RuleConfig:
    simultaneous_start: bool
    capture_enabled: bool
    forfeit_enabled: bool
    burnt_holes_enabled: bool

    def __init__(
        self,
        simultaneous_start: bool = False,
        capture_enabled: bool = True,
        forfeit_enabled: bool = True,
        burnt_holes_enabled: bool = False,
    ) -> None: ...
    @staticmethod
    def default_rules() -> RuleConfig: ...
    def __repr__(self) -> str: ...

class MoveResult:
    state: BoardState
    extra_turn: bool
    captured: int

def apply_move(state: BoardState, pit: int, rules: RuleConfig) -> MoveResult: ...
def get_legal_moves(state: BoardState) -> list[int]: ...
def is_terminal(state: BoardState) -> bool: ...
def get_winner(state: BoardState) -> int: ...
def get_final_scores(state: BoardState) -> tuple[int, int]: ...
def random_playout(state: BoardState, rules: RuleConfig, seed: int) -> int: ...
def batch_random_playouts(
    state: BoardState, rules: RuleConfig, num_playouts: int, base_seed: int
) -> tuple[int, int, int]: ...
def perft(state: BoardState, rules: RuleConfig, depth: int) -> int: ...
